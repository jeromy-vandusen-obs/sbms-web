# Set the application name from the POM. This is how the application registers with the Erueka discovery service.
spring.application.name=@project.artifactId@

# Set the build version from the POM so we can show it on screen.
build.version=@project.version@

# The following Eureka configuration is necessary when running in Docker Swarm Mode.
# ----------------------------------------------------------------------------------
# There will be multiple network interfaces created in the running container, but we need to ensure that we use the
# same one for all interactions, so we set the preferredNetworks to favour the 10.0 network.
spring.cloud.inetutils.preferredNetworks=10.0
# Use IP addresses instead of host names to bypass Docker Swarm DNS round-robin load balancing and let Ribbon do it.
eureka.instance.preferIpAddress=true
# Host names are inconsistent in Docker Swarm, so force it to always show the application name.
eureka.instance.hostName=${spring.application.name}
# Instance IDs are also inconsistent in Docker Swarm, so force it to show the application name with a unique suffix.
eureka.instance.instanceId=${spring.application.name}.${spring.application.instanceId:${random.value}}

# Set the actual list of Eureka URLs at deployment through the EUREKA_INSTANCE_LIST environment variable.
eureka.client.serviceUrl.defaultZone=${EUREKA_INSTANCE_LIST:http://localhost:8761/eureka/}

# Enable Hystrix for the Feign client so we can use fallbacks and the circuit breaker.
feign.hystrix.enabled=true

# Always produce pretty JSON output for all endpoints.
spring.jackson.serialization.indent_output=true
